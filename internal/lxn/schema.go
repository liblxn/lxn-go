// Code generated by mprotc.
// Do not edit.

package lxn

import (
	"fmt"
	"time"

	msgpack "github.com/mprot/msgpack-go"
)

var _ = fmt.Errorf
var _ time.Time
var _ *msgpack.Writer

// Catalog holds the data for a message catalog which includes localized
// messages and the locale information needed to format numbers and plurals.
type Catalog struct {
	Version  int
	Locale   Locale
	Messages []Message
}

// EncodeMsgpack implements the Encoder interface for Catalog.
func (o Catalog) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(3); err != nil {
		return err
	}
	// Version
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteInt(o.Version); err != nil {
		return err
	}
	// Locale
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = o.Locale.EncodeMsgpack(w); err != nil {
		return err
	}
	// Messages
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.Messages)); err != nil {
		return err
	}
	for _, e := range o.Messages {
		if err = e.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Catalog.
func (o *Catalog) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Version
			if o.Version, err = r.ReadInt(); err != nil {
				return err
			}
		case 2: // Locale
			if err = o.Locale.DecodeMsgpack(r); err != nil {
				return err
			}
		case 3: // Messages
			oMessagesLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.Messages) < oMessagesLen {
				o.Messages = make([]Message, oMessagesLen)
			} else {
				o.Messages = o.Messages[:oMessagesLen]
			}
			for i := 0; i < oMessagesLen; i++ {
				if err = o.Messages[i].DecodeMsgpack(r); err != nil {
					return err
				}
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// Symbols holds all the symbols that are used to format a number in a specific locale.
type Symbols struct {
	Decimal string
	Group   string
	Percent string
	Minus   string
	Inf     string
	Nan     string
	Zero    uint32
}

// EncodeMsgpack implements the Encoder interface for Symbols.
func (o Symbols) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(7); err != nil {
		return err
	}
	// Decimal
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteString(o.Decimal); err != nil {
		return err
	}
	// Group
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteString(o.Group); err != nil {
		return err
	}
	// Percent
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = w.WriteString(o.Percent); err != nil {
		return err
	}
	// Minus
	if err = w.WriteInt64(4); err != nil {
		return err
	}
	if err = w.WriteString(o.Minus); err != nil {
		return err
	}
	// Inf
	if err = w.WriteInt64(5); err != nil {
		return err
	}
	if err = w.WriteString(o.Inf); err != nil {
		return err
	}
	// Nan
	if err = w.WriteInt64(6); err != nil {
		return err
	}
	if err = w.WriteString(o.Nan); err != nil {
		return err
	}
	// Zero
	if err = w.WriteInt64(7); err != nil {
		return err
	}
	if err = w.WriteUint32(o.Zero); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Symbols.
func (o *Symbols) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Decimal
			if o.Decimal, err = r.ReadString(); err != nil {
				return err
			}
		case 2: // Group
			if o.Group, err = r.ReadString(); err != nil {
				return err
			}
		case 3: // Percent
			if o.Percent, err = r.ReadString(); err != nil {
				return err
			}
		case 4: // Minus
			if o.Minus, err = r.ReadString(); err != nil {
				return err
			}
		case 5: // Inf
			if o.Inf, err = r.ReadString(); err != nil {
				return err
			}
		case 6: // Nan
			if o.Nan, err = r.ReadString(); err != nil {
				return err
			}
		case 7: // Zero
			if o.Zero, err = r.ReadUint32(); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// NumberFormat holds all relevant information to format a number in a specific locale.
type NumberFormat struct {
	Symbols                  Symbols
	PositivePrefix           string
	PositiveSuffix           string
	NegativePrefix           string
	NegativeSuffix           string
	MinIntegerDigits         int
	MinFractionDigits        int
	MaxFractionDigits        int
	PrimaryIntegerGrouping   int
	SecondaryIntegerGrouping int
	FractionGrouping         int
}

// EncodeMsgpack implements the Encoder interface for NumberFormat.
func (o NumberFormat) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(11); err != nil {
		return err
	}
	// Symbols
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = o.Symbols.EncodeMsgpack(w); err != nil {
		return err
	}
	// PositivePrefix
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteString(o.PositivePrefix); err != nil {
		return err
	}
	// PositiveSuffix
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = w.WriteString(o.PositiveSuffix); err != nil {
		return err
	}
	// NegativePrefix
	if err = w.WriteInt64(4); err != nil {
		return err
	}
	if err = w.WriteString(o.NegativePrefix); err != nil {
		return err
	}
	// NegativeSuffix
	if err = w.WriteInt64(5); err != nil {
		return err
	}
	if err = w.WriteString(o.NegativeSuffix); err != nil {
		return err
	}
	// MinIntegerDigits
	if err = w.WriteInt64(6); err != nil {
		return err
	}
	if err = w.WriteInt(o.MinIntegerDigits); err != nil {
		return err
	}
	// MinFractionDigits
	if err = w.WriteInt64(7); err != nil {
		return err
	}
	if err = w.WriteInt(o.MinFractionDigits); err != nil {
		return err
	}
	// MaxFractionDigits
	if err = w.WriteInt64(8); err != nil {
		return err
	}
	if err = w.WriteInt(o.MaxFractionDigits); err != nil {
		return err
	}
	// PrimaryIntegerGrouping
	if err = w.WriteInt64(9); err != nil {
		return err
	}
	if err = w.WriteInt(o.PrimaryIntegerGrouping); err != nil {
		return err
	}
	// SecondaryIntegerGrouping
	if err = w.WriteInt64(10); err != nil {
		return err
	}
	if err = w.WriteInt(o.SecondaryIntegerGrouping); err != nil {
		return err
	}
	// FractionGrouping
	if err = w.WriteInt64(11); err != nil {
		return err
	}
	if err = w.WriteInt(o.FractionGrouping); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for NumberFormat.
func (o *NumberFormat) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Symbols
			if err = o.Symbols.DecodeMsgpack(r); err != nil {
				return err
			}
		case 2: // PositivePrefix
			if o.PositivePrefix, err = r.ReadString(); err != nil {
				return err
			}
		case 3: // PositiveSuffix
			if o.PositiveSuffix, err = r.ReadString(); err != nil {
				return err
			}
		case 4: // NegativePrefix
			if o.NegativePrefix, err = r.ReadString(); err != nil {
				return err
			}
		case 5: // NegativeSuffix
			if o.NegativeSuffix, err = r.ReadString(); err != nil {
				return err
			}
		case 6: // MinIntegerDigits
			if o.MinIntegerDigits, err = r.ReadInt(); err != nil {
				return err
			}
		case 7: // MinFractionDigits
			if o.MinFractionDigits, err = r.ReadInt(); err != nil {
				return err
			}
		case 8: // MaxFractionDigits
			if o.MaxFractionDigits, err = r.ReadInt(); err != nil {
				return err
			}
		case 9: // PrimaryIntegerGrouping
			if o.PrimaryIntegerGrouping, err = r.ReadInt(); err != nil {
				return err
			}
		case 10: // SecondaryIntegerGrouping
			if o.SecondaryIntegerGrouping, err = r.ReadInt(); err != nil {
				return err
			}
		case 11: // FractionGrouping
			if o.FractionGrouping, err = r.ReadInt(); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// PluralCategory is an enumeration of supported plural types. Each plural category
// can have its own translation text.
type PluralCategory int

// Enumerators for PluralCategory.
const (
	Zero  PluralCategory = 0
	One   PluralCategory = 1
	Two   PluralCategory = 2
	Few   PluralCategory = 3
	Many  PluralCategory = 4
	Other PluralCategory = 5
)

// EncodeMsgpack implements the Encoder interface for PluralCategory.
func (o PluralCategory) EncodeMsgpack(w *msgpack.Writer) error {
	return w.WriteInt(int(o))
}

// DecodeMsgpack implements the Decoder interface for PluralCategory.
func (o *PluralCategory) DecodeMsgpack(r *msgpack.Reader) error {
	val, err := r.ReadInt()
	if err != nil {
		return err
	}
	*o = PluralCategory(val)
	return nil
}

// Operand represents an operand in a plural rule.
//
// https://unicode.org/reports/tr35/tr35-numbers.html#Operands
type Operand int

// Enumerators for Operand.
const (
	AbsoluteValue        Operand = 0
	IntegerDigits        Operand = 1
	NumFracDigits        Operand = 2
	NumFracDigitsNoZeros Operand = 3
	FracDigits           Operand = 4
	FracDigitsNoZeros    Operand = 5
	CompactDecExponent   Operand = 6
)

// EncodeMsgpack implements the Encoder interface for Operand.
func (o Operand) EncodeMsgpack(w *msgpack.Writer) error {
	return w.WriteInt(int(o))
}

// DecodeMsgpack implements the Decoder interface for Operand.
func (o *Operand) DecodeMsgpack(r *msgpack.Reader) error {
	val, err := r.ReadInt()
	if err != nil {
		return err
	}
	*o = Operand(val)
	return nil
}

// Connective represents a logical connective for two plural rules. Two plural
// rules can be connected by a conjunction ('and' operator) or a disjunction
// ('or' operator). The conjunction binds more tightly.
type Connective int

// Enumerators for Connective.
const (
	None        Connective = 0
	Conjunction Connective = 1
	Disjunction Connective = 2
)

// EncodeMsgpack implements the Encoder interface for Connective.
func (o Connective) EncodeMsgpack(w *msgpack.Writer) error {
	return w.WriteInt(int(o))
}

// DecodeMsgpack implements the Decoder interface for Connective.
func (o *Connective) DecodeMsgpack(r *msgpack.Reader) error {
	val, err := r.ReadInt()
	if err != nil {
		return err
	}
	*o = Connective(val)
	return nil
}

// Range represents an integer range, where both bounds are inclusive.
// If the lower bound equals the upper bound, the range will collapse
// to a single value.
type Range struct {
	LowerBound int
	UpperBound int
}

// EncodeMsgpack implements the Encoder interface for Range.
func (o Range) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(2); err != nil {
		return err
	}
	// LowerBound
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteInt(o.LowerBound); err != nil {
		return err
	}
	// UpperBound
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteInt(o.UpperBound); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Range.
func (o *Range) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // LowerBound
			if o.LowerBound, err = r.ReadInt(); err != nil {
				return err
			}
		case 2: // UpperBound
			if o.UpperBound, err = r.ReadInt(); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// PluralRule holds the data for a single plural rule. The Modulo field defines the
// modulo divisor for the operand. If Modulo is zero, no remainder has to be calculated.
//
// The plural rule could be connected with another rule. If so, the Connective field is
// set to the respective value (Conjunction or Disjunction). Otherwise the Connective
// field is set to None and there is no follow-up rule.
//
// Example for a plural rule: i%10=1..3
type PluralRule struct {
	Operand    Operand
	Modulo     int
	Negate     bool
	Ranges     []Range
	Connective Connective
}

// EncodeMsgpack implements the Encoder interface for PluralRule.
func (o PluralRule) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(5); err != nil {
		return err
	}
	// Operand
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = o.Operand.EncodeMsgpack(w); err != nil {
		return err
	}
	// Modulo
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteInt(o.Modulo); err != nil {
		return err
	}
	// Negate
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = w.WriteBool(o.Negate); err != nil {
		return err
	}
	// Ranges
	if err = w.WriteInt64(4); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.Ranges)); err != nil {
		return err
	}
	for _, e := range o.Ranges {
		if err = e.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	// Connective
	if err = w.WriteInt64(5); err != nil {
		return err
	}
	if err = o.Connective.EncodeMsgpack(w); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for PluralRule.
func (o *PluralRule) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Operand
			if err = o.Operand.DecodeMsgpack(r); err != nil {
				return err
			}
		case 2: // Modulo
			if o.Modulo, err = r.ReadInt(); err != nil {
				return err
			}
		case 3: // Negate
			if o.Negate, err = r.ReadBool(); err != nil {
				return err
			}
		case 4: // Ranges
			oRangesLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.Ranges) < oRangesLen {
				o.Ranges = make([]Range, oRangesLen)
			} else {
				o.Ranges = o.Ranges[:oRangesLen]
			}
			for i := 0; i < oRangesLen; i++ {
				if err = o.Ranges[i].DecodeMsgpack(r); err != nil {
					return err
				}
			}
		case 5: // Connective
			if err = o.Connective.DecodeMsgpack(r); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// Plural represents a single plural form. It holds a collection of plural rules
// for a specific plural category where all rules are connected with each other (see
// Rule and Connective).
type Plural struct {
	Category PluralCategory
	Rules    []PluralRule
}

// EncodeMsgpack implements the Encoder interface for Plural.
func (o Plural) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(2); err != nil {
		return err
	}
	// Category
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = o.Category.EncodeMsgpack(w); err != nil {
		return err
	}
	// Rules
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.Rules)); err != nil {
		return err
	}
	for _, e := range o.Rules {
		if err = e.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Plural.
func (o *Plural) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Category
			if err = o.Category.DecodeMsgpack(r); err != nil {
				return err
			}
		case 2: // Rules
			oRulesLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.Rules) < oRulesLen {
				o.Rules = make([]PluralRule, oRulesLen)
			} else {
				o.Rules = o.Rules[:oRulesLen]
			}
			for i := 0; i < oRulesLen; i++ {
				if err = o.Rules[i].DecodeMsgpack(r); err != nil {
					return err
				}
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// Locale holds the data which is necessary to format data in a region
// specific format.
type Locale struct {
	ID              string
	DecimalFormat   NumberFormat
	MoneyFormat     NumberFormat
	PercentFormat   NumberFormat
	CardinalPlurals []Plural
	OrdinalPlurals  []Plural
}

// EncodeMsgpack implements the Encoder interface for Locale.
func (o Locale) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(6); err != nil {
		return err
	}
	// ID
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteString(o.ID); err != nil {
		return err
	}
	// DecimalFormat
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = o.DecimalFormat.EncodeMsgpack(w); err != nil {
		return err
	}
	// MoneyFormat
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = o.MoneyFormat.EncodeMsgpack(w); err != nil {
		return err
	}
	// PercentFormat
	if err = w.WriteInt64(4); err != nil {
		return err
	}
	if err = o.PercentFormat.EncodeMsgpack(w); err != nil {
		return err
	}
	// CardinalPlurals
	if err = w.WriteInt64(5); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.CardinalPlurals)); err != nil {
		return err
	}
	for _, e := range o.CardinalPlurals {
		if err = e.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	// OrdinalPlurals
	if err = w.WriteInt64(6); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.OrdinalPlurals)); err != nil {
		return err
	}
	for _, e := range o.OrdinalPlurals {
		if err = e.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Locale.
func (o *Locale) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // ID
			if o.ID, err = r.ReadString(); err != nil {
				return err
			}
		case 2: // DecimalFormat
			if err = o.DecimalFormat.DecodeMsgpack(r); err != nil {
				return err
			}
		case 3: // MoneyFormat
			if err = o.MoneyFormat.DecodeMsgpack(r); err != nil {
				return err
			}
		case 4: // PercentFormat
			if err = o.PercentFormat.DecodeMsgpack(r); err != nil {
				return err
			}
		case 5: // CardinalPlurals
			oCardinalPluralsLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.CardinalPlurals) < oCardinalPluralsLen {
				o.CardinalPlurals = make([]Plural, oCardinalPluralsLen)
			} else {
				o.CardinalPlurals = o.CardinalPlurals[:oCardinalPluralsLen]
			}
			for i := 0; i < oCardinalPluralsLen; i++ {
				if err = o.CardinalPlurals[i].DecodeMsgpack(r); err != nil {
					return err
				}
			}
		case 6: // OrdinalPlurals
			oOrdinalPluralsLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.OrdinalPlurals) < oOrdinalPluralsLen {
				o.OrdinalPlurals = make([]Plural, oOrdinalPluralsLen)
			} else {
				o.OrdinalPlurals = o.OrdinalPlurals[:oOrdinalPluralsLen]
			}
			for i := 0; i < oOrdinalPluralsLen; i++ {
				if err = o.OrdinalPlurals[i].DecodeMsgpack(r); err != nil {
					return err
				}
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// Message holds the data for a single message. Each message consists of
// a list of fragments which has to be concatenated to receive the final
// message text. If the message does not contain any replacement variables,
// there will only be a single string fragment.
type Message struct {
	Section      string
	Key          string
	Text         []string
	Replacements []Replacement
}

// EncodeMsgpack implements the Encoder interface for Message.
func (o Message) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(4); err != nil {
		return err
	}
	// Section
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteString(o.Section); err != nil {
		return err
	}
	// Key
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteString(o.Key); err != nil {
		return err
	}
	// Text
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.Text)); err != nil {
		return err
	}
	for _, e := range o.Text {
		if err = w.WriteString(e); err != nil {
			return err
		}
	}
	// Replacements
	if err = w.WriteInt64(4); err != nil {
		return err
	}
	if err = w.WriteArrayHeader(len(o.Replacements)); err != nil {
		return err
	}
	for _, e := range o.Replacements {
		if err = e.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Message.
func (o *Message) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Section
			if o.Section, err = r.ReadString(); err != nil {
				return err
			}
		case 2: // Key
			if o.Key, err = r.ReadString(); err != nil {
				return err
			}
		case 3: // Text
			oTextLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.Text) < oTextLen {
				o.Text = make([]string, oTextLen)
			} else {
				o.Text = o.Text[:oTextLen]
			}
			for i := 0; i < oTextLen; i++ {
				if o.Text[i], err = r.ReadString(); err != nil {
					return err
				}
			}
		case 4: // Replacements
			oReplacementsLen, err := r.ReadArrayHeader()
			if err != nil {
				return err
			}
			if cap(o.Replacements) < oReplacementsLen {
				o.Replacements = make([]Replacement, oReplacementsLen)
			} else {
				o.Replacements = o.Replacements[:oReplacementsLen]
			}
			for i := 0; i < oReplacementsLen; i++ {
				if err = o.Replacements[i].DecodeMsgpack(r); err != nil {
					return err
				}
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// Replacement describes a variable piece of text in a message which will be replaced
// during runtime. The key defines the variable's name which will be passed in. The type
// contains more details about the particular replacement.
type Replacement struct {
	Key     string
	TextPos int
	Type    ReplacementType
	Details ReplacementDetails
}

// EncodeMsgpack implements the Encoder interface for Replacement.
func (o Replacement) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(4); err != nil {
		return err
	}
	// Key
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteString(o.Key); err != nil {
		return err
	}
	// TextPos
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteInt(o.TextPos); err != nil {
		return err
	}
	// Type
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = o.Type.EncodeMsgpack(w); err != nil {
		return err
	}
	// Details
	if err = w.WriteInt64(4); err != nil {
		return err
	}
	if err = o.Details.EncodeMsgpack(w); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for Replacement.
func (o *Replacement) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Key
			if o.Key, err = r.ReadString(); err != nil {
				return err
			}
		case 2: // TextPos
			if o.TextPos, err = r.ReadInt(); err != nil {
				return err
			}
		case 3: // Type
			if err = o.Type.DecodeMsgpack(r); err != nil {
				return err
			}
		case 4: // Details
			if err = o.Details.DecodeMsgpack(r); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// ReplacementDetails holds the details for particular replacements. The special
// EmptyDetails branch indicates that there a no details for the replacement type.
type ReplacementDetails struct {
	Value interface{} // EmptyDetails, MoneyDetails, PluralDetails, or SelectDetails
}

// EncodeMsgpack implements the Encoder interface for ReplacementDetails.
func (o ReplacementDetails) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteArrayHeader(2); err != nil {
		return err
	}
	switch v := o.Value.(type) {
	case EmptyDetails:
		if err = w.WriteInt64(1); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	case MoneyDetails:
		if err = w.WriteInt64(2); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	case PluralDetails:
		if err = w.WriteInt64(3); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	case SelectDetails:
		if err = w.WriteInt64(4); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid ReplacementDetails type %T", o.Value)
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for ReplacementDetails.
func (o *ReplacementDetails) DecodeMsgpack(r *msgpack.Reader) error {
	if err := r.ReadArrayHeaderWithSize(2); err != nil {
		return err
	}
	ord, err := r.ReadInt64()
	if err != nil {
		return err
	}
	switch ord {
	case 1: // EmptyDetails
		var v EmptyDetails
		if err = v.DecodeMsgpack(r); err != nil {
			return err
		}
		o.Value = v
	case 2: // MoneyDetails
		var v MoneyDetails
		if err = v.DecodeMsgpack(r); err != nil {
			return err
		}
		o.Value = v
	case 3: // PluralDetails
		var v PluralDetails
		if err = v.DecodeMsgpack(r); err != nil {
			return err
		}
		o.Value = v
	case 4: // SelectDetails
		var v SelectDetails
		if err = v.DecodeMsgpack(r); err != nil {
			return err
		}
		o.Value = v
	default:
		return fmt.Errorf("invalid ordinal %d for ReplacementDetails", ord)
	}
	return nil
}

// ReplacementType describes the type of a replacement. Each type contains the details
// necessary to render the variable's value.
type ReplacementType int

// Enumerators for ReplacementType.
const (
	StringReplacement  ReplacementType = 1
	NumberReplacement  ReplacementType = 2
	PercentReplacement ReplacementType = 3
	MoneyReplacement   ReplacementType = 4
	PluralReplacement  ReplacementType = 5
	SelectReplacement  ReplacementType = 6
)

// EncodeMsgpack implements the Encoder interface for ReplacementType.
func (o ReplacementType) EncodeMsgpack(w *msgpack.Writer) error {
	return w.WriteInt(int(o))
}

// DecodeMsgpack implements the Decoder interface for ReplacementType.
func (o *ReplacementType) DecodeMsgpack(r *msgpack.Reader) error {
	val, err := r.ReadInt()
	if err != nil {
		return err
	}
	*o = ReplacementType(val)
	return nil
}

// PluralType is an enumeration for the types of a plural form.
type PluralType int

// Enumerators for PluralType.
const (
	Cardinal PluralType = 0
	Ordinal  PluralType = 1
)

// EncodeMsgpack implements the Encoder interface for PluralType.
func (o PluralType) EncodeMsgpack(w *msgpack.Writer) error {
	return w.WriteInt(int(o))
}

// DecodeMsgpack implements the Decoder interface for PluralType.
func (o *PluralType) DecodeMsgpack(r *msgpack.Reader) error {
	val, err := r.ReadInt()
	if err != nil {
		return err
	}
	*o = PluralType(val)
	return nil
}

// EmptyDetails describes a special type for a replacement that has no further
// details attached.
type EmptyDetails struct {
}

// EncodeMsgpack implements the Encoder interface for EmptyDetails.
func (o EmptyDetails) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(0); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for EmptyDetails.
func (o *EmptyDetails) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// MoneyDetails contains the replacement details for amounts of money.
type MoneyDetails struct {
	Currency string
}

// EncodeMsgpack implements the Encoder interface for MoneyDetails.
func (o MoneyDetails) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(1); err != nil {
		return err
	}
	// Currency
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteString(o.Currency); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for MoneyDetails.
func (o *MoneyDetails) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Currency
			if o.Currency, err = r.ReadString(); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// PluralDetails contains the replacement details for plurals. Depending on the
// variable, different text for each plural rule can be selected. It contains
// the variants for the supported plural categories and custom overwrites.
type PluralDetails struct {
	Type     PluralType
	Variants map[PluralCategory]Message
	Custom   map[int64]Message
}

// EncodeMsgpack implements the Encoder interface for PluralDetails.
func (o PluralDetails) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(3); err != nil {
		return err
	}
	// Type
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = o.Type.EncodeMsgpack(w); err != nil {
		return err
	}
	// Variants
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteMapHeader(len(o.Variants)); err != nil {
		return err
	}
	for k, v := range o.Variants {
		if err = k.EncodeMsgpack(w); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	// Custom
	if err = w.WriteInt64(3); err != nil {
		return err
	}
	if err = w.WriteMapHeader(len(o.Custom)); err != nil {
		return err
	}
	for k, v := range o.Custom {
		if err = w.WriteInt64(k); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for PluralDetails.
func (o *PluralDetails) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Type
			if err = o.Type.DecodeMsgpack(r); err != nil {
				return err
			}
		case 2: // Variants
			oVariantsLen, err := r.ReadMapHeader()
			if err != nil {
				return err
			}
			if o.Variants == nil {
				o.Variants = make(map[PluralCategory]Message, oVariantsLen)
			}
			for i := 0; i < oVariantsLen; i++ {
				var k PluralCategory
				if err = k.DecodeMsgpack(r); err != nil {
					return err
				}
				var v Message
				if err = v.DecodeMsgpack(r); err != nil {
					return err
				}
				o.Variants[k] = v
			}
		case 3: // Custom
			oCustomLen, err := r.ReadMapHeader()
			if err != nil {
				return err
			}
			if o.Custom == nil {
				o.Custom = make(map[int64]Message, oCustomLen)
			}
			for i := 0; i < oCustomLen; i++ {
				var k int64
				if k, err = r.ReadInt64(); err != nil {
					return err
				}
				var v Message
				if err = v.DecodeMsgpack(r); err != nil {
					return err
				}
				o.Custom[k] = v
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}

// SelectDetails contains the replacement details to select a text fragment
// depending on the given variable. The fallback is an optional value which
// describes the default case.
type SelectDetails struct {
	Cases    map[string]Message
	Fallback string
}

// EncodeMsgpack implements the Encoder interface for SelectDetails.
func (o SelectDetails) EncodeMsgpack(w *msgpack.Writer) (err error) {
	if err = w.WriteMapHeader(2); err != nil {
		return err
	}
	// Cases
	if err = w.WriteInt64(1); err != nil {
		return err
	}
	if err = w.WriteMapHeader(len(o.Cases)); err != nil {
		return err
	}
	for k, v := range o.Cases {
		if err = w.WriteString(k); err != nil {
			return err
		}
		if err = v.EncodeMsgpack(w); err != nil {
			return err
		}
	}
	// Fallback
	if err = w.WriteInt64(2); err != nil {
		return err
	}
	if err = w.WriteString(o.Fallback); err != nil {
		return err
	}
	return nil
}

// DecodeMsgpack implements the Decoder interface for SelectDetails.
func (o *SelectDetails) DecodeMsgpack(r *msgpack.Reader) error {
	n, err := r.ReadMapHeader()
	if err != nil {
		return err
	}
	for i := 0; i < n; i++ {
		ord, err := r.ReadInt64()
		if err != nil {
			return err
		}
		switch ord {
		case 1: // Cases
			oCasesLen, err := r.ReadMapHeader()
			if err != nil {
				return err
			}
			if o.Cases == nil {
				o.Cases = make(map[string]Message, oCasesLen)
			}
			for i := 0; i < oCasesLen; i++ {
				var k string
				if k, err = r.ReadString(); err != nil {
					return err
				}
				var v Message
				if err = v.DecodeMsgpack(r); err != nil {
					return err
				}
				o.Cases[k] = v
			}
		case 2: // Fallback
			if o.Fallback, err = r.ReadString(); err != nil {
				return err
			}
		default:
			if err := r.Skip(); err != nil {
				return err
			}
		}
	}
	return nil
}
